# Macors

来自https://doc.rust-lang.org/book/ch20-05-macros.html

We’ve used macros like `println!` throughout this book, but we haven’t fully explored what a macro is and how it works. The term *macro* refers to a family of features in Rust: *declarative* macros with `macro_rules!` and three kinds of *procedural* macros:

- Custom `#[derive]` macros that specify code added with the `derive` attribute used on structs and enums
- Attribute-like macros that define custom attributes usable on any item
- Function-like macros that look like function calls but operate on the tokens specified as their argument

We’ll talk about each of these in turn, but first, let’s look at why we even need macros when we already have functions.

我们已通过这本书像 println! 一样使用了macros，但我们还没有充分探讨什么是一个macro以及它的工作原理。macro 术语指的是一系列rust的特性：带macro_rules! 的 declarative macros (声明式宏) 和 三种 procedural macros (过程宏)：

- Custome #[derive] marcros, 用于给 strcts 和 enums 的代码添加 derive 相关属性
- Attribute-like macros, 用于定义自定义属性，可用于任何 item
- Function-like macros, 用于定义看起来像函数调用的宏，但是它们操作的是作为参数指定的token

我们将依次讨论其中的每一个，首先，让我们看看为什么我们已经有了 function 还要 macros。

## The Difference Between Macros and Functions

Fundamentally, macros are a way of writing code that writes other code, which is known as metaprogramming. In Appendix C, we discuss the derive attribute, which generates an implementation of various traits for you. We’ve also used the println! and vec! macros throughout the book. All of these macros expand to produce more code than the code you’ve written manually.

从根本上说，macros 是一种写其他代码的写代码方式，这被称为 metaprograming。在附录C 中，我们讨论了 derive attribute，它为你生成了各种 trait 的实现。我们还通过此书使用了 println！和 vec！macros。所有这些 macors 都会展开生成比你手动编写的代码更多的代码。

Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. However, macros have some additional powers that functions don’t have.

Metaprogramming 对于减少你需要写和维护的代码量是非常有用的，这也是 function 的角色之一。然而，macros 有一些额外的功能是 function 没有的。

A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call println!("hello") with one argument or println!("hello {}", name) with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.

The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you’re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.

Another important difference between macros and functions is that you must define macros or bring them into scope before you call them in a file, as opposed to functions you can define anywhere and call anywhere.


